{"body":"TINY-LEX(MyLex)\r\n========\r\n\r\nOverview\r\n--------\r\n\r\nMyLex is a tiny lexical analyzer implemented in C++ and it is my home work of\r\ncompiler.\r\n\r\nSTEPS\r\n-----\r\n1. parse .mylex file\r\n2. generate a list of NFA by the regex strings\r\n3. generate a large NFA by combining the NFAs\r\n4. convert the NFA to a DFA\r\n5. minimize the DFA\r\n6. generate the c code from DFA\r\n\r\nSome Important Algorithms\r\n-------------------------\r\n1. convert regex to postfix expression\r\n2. convert postfix expression to NFA, [reference](http://swtch.com/~rsc/regexp/regexp1.html)\r\n3. convert NFA to DFA\r\n4. minimize DFA\r\n\r\nCompile And Run\r\n---------------\r\n\r\n### Environment for MyLex\r\n\r\n1. OS: Linux , Unix or Mac OS\r\n2. Compiler: g++ or clang\r\n3. Library: [Boost](http://www.boost.org/)\r\n\r\n### Environment for c code generated by MyLex\r\n\r\n1. OS: Linux , Unix or Mac OS\r\n2. Compiler: gcc or clang, *Must Use Compilers Which Support C99*\r\n\r\n### Compiler MyLex\r\n\r\n```\r\nFor Debug\r\n  make DEBUG=1\r\n\r\nNot For Debug\r\n  make\r\n```\r\n\r\n### How to use\r\n\r\n```\r\nmylex infile [outfile](default output to stdout)\r\n```\r\n\r\n### Sample\r\n```\r\nmake\r\n./mylex sample/c_lex.mylex > c_lex.c\r\nmake c_lex\r\n```\r\n\r\nMyLex Syntax\r\n------------\r\n\r\n* Sample: [c_lex.mylex](https://github.com/sheimi/tiny-lex/blob/master/sample/c_lex.mylex)\r\n* Sample Input: [sample.c](https://github.com/sheimi/tiny-lex/blob/master/sample/sample.c)\r\n* Sample Output: [sample.out](https://github.com/sheimi/tiny-lex/blob/master/sample/sample.out)\r\n\r\nFile Format\r\n```\r\n%{\r\n[declear]\r\n%}\r\n%%\r\n[Entry]\r\n%%\r\n[Code]\r\n```\r\n\r\nEntry Format\r\n\r\n```\r\n[Regex] {\r\n  [Handler] with the param (shm_token)\r\n}\r\n```\r\n\r\nAnd there are some constrains:\r\n* you must provide a main function in 'Code' section\r\n* in 'main', you must invoke myylex(char* filename, void (*func)())\r\n* you must pass a function pointer when you invoke myylex\r\n* in myylex, you can use the 'Token List'\r\n\r\n```\r\n// To travel the token list\r\n// You should define trav_func\r\nvoid iter_list(void (*trav_func)(Token*));\r\n\r\n// print a specific token (a pre-defined trav_func)\r\nvoid print_token(Token* token);\r\n\r\n// invoke in 'main'\r\nvoid myylex(char* input, void (*func)());\r\n\r\n// init a iter\r\n#define INIT_ITER(iter) \r\n// get next token\r\n#define ITER_NEXT(iter)  (iter = iter->next)\r\n// if there is a next token\r\n#define ITER_HASNEXT(iter) (iter != NULL && iter->next != NULL)\r\n// if the iter is NULL\r\n#define ITER_ISEND(iter) (iter == NULL)\r\n```\r\n","tagline":"My Tiny Lexical Analyzer","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Tiny Lex (MyLex)","google":"UA-35791128-1"}